## Copyright (C) 2016 Jeremiah Orians
## This file is part of stage0.
##
## stage0 is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## stage0 is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with stage0.  If not, see <http://www.gnu.org/licenses/>.

#:start
2D2B0001	# LOADUI R11 1 ; Our toggle
# ;; R14 is storing our condition code
# ;; R15 is storing our nybble

# ;; Prep TAPE_01
2D201100	 # LOADUI R0 0x1100
42100000	# FOPEN_READ

# ;; Prep TAPE_02
2D201101	# LOADUI R0 0x1101
42100001	# FOPEN_WRITE

# ;; Main program loop
# ;; Halts when done
#:loop 14
2D211100	# LOADUI R1 0x1100 ; Read from tape_01
42100100	# FGETC ; Read a Char

# ;; Check for EOF
2CC000b8	# JUMP.NP R0 @finish
3C000034	# JUMP @hex ; Convert it

# :loop_1 24
2CC0fff0	# JUMP.NP R0 @loop ; Don't use nonhex chars
2C9B0010	# JUMP.Z R11 @loop_2 ; Jump if toggled

# ;; Process first byte of pair
B0F0000f	# ANDI R15 R0 0xF ; Store First nibble
0D00002B	# FALSE R11 ; Flip the toggle
3C00ffe0	# JUMP @loop

# :loop_2 38
2D5F0004	# SL0I R15 4 ; Shift our first nibble
B000000f	# ANDI R0 R0 0xF ; Mask out top
0500000F	# ADD R0 R0 R15 ; Combine nibbles
2D1B0001	# LOADI R11 1 ; Flip the toggle
2D211101	# LOADUI R1 0x1101 ; Write the combined byte
42100200	# FPUTC ; To TAPE_02
3C00ffc4	# JUMP @loop ; Try to get more bytes

# ;; Hex function
# ;; Converts Ascii chars to their hex values
# ;; Or -1 if not a hex char
# ;; Returns to whatever called it
#:hex 54
# ;; Deal with line comments starting with #
1FE00023	# CMPUI R14 R0 35
2C5E0060	# JUMP.E R14 @ascii_comment
# ;; Deal with line comments starting with ;
1FE0003b	# CMPUI R14 R0 59
2C5E0058	# JUMP.E R14 @ascii_comment
# ;; Deal with all ascii less than '0'
1FE00030	# CMPUI R14 R0 48
2C8E0048	# JUMP.L R14 @ascii_other
# ;; Deal with '0'-'9'
1FE00039	# CMPUI R14 R0 57
2C7E0028	# JUMP.LE R14 @ascii_num
# ;; Deal with all ascii less than 'A'
1FE00041	# CMPUI R14 R0 65
2C8E0038	# JUMP.L R14 @ascii_other
# ;; Deal with 'A'-'F'
1FE00046	# CMPUI R14 R0 70
2C7E0028	# JUMP.LE R14 @ascii_high
# ;; Deal with all ascii less than 'a'
1FE00061	# CMPUI R14 R0 97
2C8E0028	# JUMP.L R14 @ascii_other
# ;;  Deal with 'a'-'f'
1FE00066	# CMPUI R14 R0 102
2C7E0010	# JUMP.LE R14 @ascii_low
# ;; Ignore the rest
3C00001c	# JUMP @ascii_other

# :ascii_num 98
11000030	# SUBUI R0 R0 48
3C00ff88	# JUMP @loop_1
# :ascii_low a0
11000057	# SUBUI R0 R0 87
3C00ff80	# JUMP @loop_1
# :ascii_high a8
11000037	# SUBUI R0 R0 55
3C00ff78	# JUMP @loop_1
# :ascii_other b0
0D000030	# TRUE R0
3C00ff70	# JUMP @loop_1
# :ascii_comment b8
2D211100	# LOADUI R1 0x1100 ; Read from TAPE_01
42100100	# FGETC ; Read another char
1FE0000a	# CMPUI R14 R0 10 ; Stop at the end of line
2D210000	# LOADUI R1 0 ; Write to TTY
42100200	# FPUTC ; The char we just read
2C6Effec	# JUMP.NE R14 @ascii_comment ; Otherwise keep looping
3C00ffe0	# JUMP @ascii_other

# ;; Finish function
# ;; Cleans up at the end of the program
# ;; Performs the HALT
# :finish d4
2D201100	# LOADUI R0 0x1100 ; Close TAPE_01
42100002	# FCLOSE
2D201101	# LOADUI R0 0x1101 ; Close TAPE_02
42100002	# FCLOSE
FFFFFFFF	# HALT
