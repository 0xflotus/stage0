## Copyright (C) 2016 Jeremiah Orians
## This file is part of stage0.
##
## stage0 is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## stage0 is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with stage0.  If not, see <http://www.gnu.org/licenses/>.

#:start 0
2D2B019C	# LOADUI R11 $table ; Where we are putting our address pointers
0D00003C	# TRUE R12 ; Our toggle
0D00002D	# FALSE R13 ; Our PC counter
2D2E0040	# LOADUI R14 $getLables_2 ; our first iterator
# ;; We will be using R15 for holding our processed nybbles

# ;; Prep TAPE_01
2D201100	# LOADUI R0 0x1100
42100000	# FOPEN_READ

# ;; Prep TAPE_02
2D201101	# LOADUI R0 0x1101
42100001	# FOPEN_WRITE

2D211100	# LOADUI R1 0x1100 ; Read from tape_01

# ;; Function for collecting the address of all labels
#:getLables 24
42100100	# FGETC ; Read a Char
2CC00048	# JUMP.NP R0 @stage2 ; Check for EOF

# ;; Check for Label
A030003A	# CMPSKIPI.NE R0 58 ; If the Char is : the next char is the label
3C000030	# JUMP @storeLabel

# ;; Check for pointer to label
A0300040	# CMPSKIPI.NE R0 64 ; If the Char is @ the next char is the pointer to a label
3C00001C	# JUMP @ignorePointer

# ;; Otherwise attempt to process
3C0000DC	# JUMP @hex ; Convert it

#:getLables_2 40
2CC0FFE4	# JUMP.NP R0 @getLables ; Don't record, nonhex values
090006CC	# NOT R12 R12 ; Flip the toggle
2C9CFFDC	# JUMP.Z R12 @getLables ; First half doesn't need anything

# ;; Deal with case of second half of byte
0FDD0001	# ADDUI R13 R13 1 ; increment PC now that we have a full byte
3C00FFD4	# JUMP @getLables

#:ignorePointer 54
# ;; Ignore the pointer for now
42100100	# FGETC ; Read a Char
0FDD0002	# ADDUI R13 R13 2 ; The pointer will end up taking 2 bytes
3C00FFC8	# JUMP @getLables

# ;; Function for storing the address of the label
#:storeLabel 60
# ;; Get the char of the Label
42100100	# FGETC ; Read a Char

# ;; We require 2 bytes to store the pointer values
2D500001	# SL0I R0 1 ; Thus we multiply our label by 2

# ;; Store the current Program counter
0504ADB0	# STOREX16 R13 R11 R0

# ;; Label is safely stored, return
3C00FFB8	# JUMP @getLables


# ;; Now that we have all of the label addresses,
# ;; We can process input to produce our output
#:stage2 70
# ;; We first need to rewind tape_01 to perform our second pass
2D201100	# LOADUI R0 0x1100
42100003	# REWIND

# ;; Reset our toggle and counter
2D291101	# LOADUI R9 0x1101 ; Where to write the combined byte
0D00003C	# TRUE R12 ; Our toggle
0D00002D	# FALSE R13 ; Our PC counter
2D2E00A4	# LOADUI R14 $loop_hex ; The hex return target

#:loop 88
42100100	# FGETC ; Read a Char
2CC000FC	# JUMP.NP R0 @finish ; Check for EOF

# ;; Check for Label
A030003A	# CMPSKIPI.NE R0 58 ; Make sure we jump over the label
3C000044	# JUMP @ignoreLabel

# ;; Check for Pointer
A0300040	# CMPSKIPI.NE R0 64 ; If it is a pointer Deal with it
3C000044	# JUMP @storePointer

# ;; Process Char
3C000078	# JUMP @hex ; Convert it

#:loop_hex a4
2CC0FFE4	# JUMP.NP R0 @loop ; Don't use nonhex chars
090006CC	# NOT R12 R12 ; Flip the toggle
2CAC000C	# JUMP.NZ R12 @loop_second_nybble ; Jump if toggled

# ;; Process first byte of pair
B0F0000F	# ANDI R15 R0 0xF ; Store First nibble
3C00FFD4	# JUMP @loop

#:loop_second_nybble b8
2D5F0004	# SL0I R15 4 ; Shift our first nibble
B000000F	# ANDI R0 R0 0xF ; Mask out top
0500000F	# ADD R0 R0 R15 ; Combine nibbles
09000319	# SWAP R1 R9 ; Set to write to tape_2
42100200	# FPUTC ; To TAPE_02
09000319	# SWAP R1 R9 ; Restore from tape_1
0FDD0001	# ADDUI R13 R13 1 ; increment PC now that we have a full byte
3C00FFB4	# JUMP @loop ; Try to get more bytes

#:ignoreLabel d8
# ;; Consume next char
42100100	# FGETC ; Read a Char
3C00FFAC	# JUMP @loop

#:storePointer e0
# ;; Correct the PC to reflect the size of the pointer
0FDD0002	# ADDUI R13 R13 2 ; Exactly 2 bytes

# ;; Get the char of the Label
42100100	# FGETC ; Read a Char

# ;; Since we stored a short pointer taking up 2 bytes
2D500001	# SL0I R0 1 ; Thus we multiply our label by 2 to get where it is stored
0503C3B0	# LOADXU16 R3 R11 R0 ; Load the address of the label

# ;; We now have to calculate the distance and store the 2 bytes
0500233D	# SUB R3 R3 R13 ; First determine the difference between the current PC and the stored PC of the label
0F330004	# ADDUI R3 R3 4 ; Adjust for relative positioning

# ;; Store Upper byte
B003FF00	# ANDI R0 R3 0xFF00 ; Mask out everything but top byte
2D400008	# SARI R0 8 ; Drop the bottom 8 bits
09000319	# SWAP R1 R9 ; Write the byte
42100200	# FPUTC ; To TAPE_02

# ;; Store Lower byte
B00300FF	# ANDI R0 R3 0xFF ; Preserve bottom half for later
42100200	# FPUTC ; Write the byte to TAPE_02
09000319	# SWAP R1 R9 ; Restore Read
3C00FF74	# JUMP @loop

# ;; Hex function
# ;; Returns hex value of ascii char
# ;; Or -1 if not a hex char
#:hex 118
# ;; Deal with line comments starting with #
A0300023	# CMPSKIPI.NE R0 35
3C000058	# JUMP @ascii_comment

# ;; Deal with line comments starting with ;
A030003B	# CMPSKIPI.NE R0 59
3C000050	# JUMP @ascii_comment

# ;; Deal with all ascii less than '0'
A0100030	# CMPSKIPI.GE R0 48
3C000054	# JUMP @ascii_other

# ;; Deal with '0'-'9'
A0000039	# CMPSKIPI.G R0 57
3C000028	# JUMP @ascii_num

# ;; Deal with all ascii less than 'A'
A0100041	# CMPSKIPI.GE R0 65
3C000044	# JUMP @ascii_other

# ;; Deal with 'A'-'F'
A0000046	# CMPSKIPI.G R0 70
3C000028	# JUMP @ascii_high

# ;; Deal with all ascii less than 'a'
A0100061	# CMPSKIPI.GE R0 97
3C000034	# JUMP @ascii_other

# ;;  Deal with 'a'-'f'
A0000066	# CMPSKIPI.G R0 102
3C000010	# JUMP @ascii_low

# ;; Ignore the rest
3C000028	# JUMP @ascii_other

#:ascii_num 15c
11000030	# SUBUI R0 R0 48
0D01000E	# JSR_COROUTINE R14

#:ascii_low 164
11000057	# SUBUI R0 R0 87
0D01000E	# JSR_COROUTINE R14

#:ascii_high 16c
11000037	# SUBUI R0 R0 55
0D01000E	# JSR_COROUTINE R14

#:ascii_comment 174
42100100	# FGETC ; Read another char
A020000A	# CMPSKIPI.E R0 10 ; Stop at the end of line
3C00FFF8	# JUMP @ascii_comment ; Otherwise keep looping

#:ascii_other 180
0D000030	# TRUE R0
0D01000E	# JSR_COROUTINE R14

#:finish 188
2D201100	# LOADUI R0 0x1100 ; Close TAPE_01
42100002	# FCLOSE
2D201101	# LOADUI R0 0x1101 ; Close TAPE_02
42100002	# FCLOSE
FFFFFFFF	# HALT

# ;; Where all of our pointers will be stored for our locations
#:table 19c
